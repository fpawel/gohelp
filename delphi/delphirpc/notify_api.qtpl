// // Code generated. DO NOT EDIT.
{% package delphirpc %}

{% func (x *NotifyServicesSrc) GoFile() %}
package notify

import (
	{% for imp := range x.goImports %}"{%s imp %}"
    {% endfor %}
)

type msg int

const (
    msg{%s x.services[0].serviceName %} msg = iota
    {% for _,m := range x.services[1:] %}msg{%s m.serviceName %}
    {% endfor %}
)

{% for _,m := range x.services %}func {%s m.serviceName %}(log *structlog.Logger, arg {%s m.goType %}) {
    if log != nil {
        msg{%s m.serviceName %}.Log(log)(peer.WindowClassName + ": {%s m.serviceName %}: "+ fmt.Sprintf("%+v",arg), "MSG", msg{%s m.serviceName %}, )
    }
    {% if m.serviceName != "Warning" %}go {% endif %}peer.{%s m.notifyFunc %}( uintptr(msg{%s m.serviceName %}), {%s= m.instructionArg %} )
}
{% if m.notifyFunc == "NotifyStr" %}
func {%s m.serviceName %}f(log *structlog.Logger, format string, a ...interface{}) {
    if log != nil {
        msg{%s m.serviceName %}.Log(log)(peer.WindowClassName + ": {%s m.serviceName %}: " + fmt.Sprintf(format,a...), "MSG", msg{%s m.serviceName %}, )
    }
    {% if m.serviceName != "Warning" %}go {% endif %}peer.Notifyf( uintptr(msg{%s m.serviceName %}), format, a... )
}{% endif %}
{% endfor %}



{% endfunc %}